## GC是什么？
        GC通常也叫垃圾回收，垃圾回收在现在的代码语言中具体是指自动垃圾回收，自动回收堆内存的工具。
## 什么样的垃圾会被GC
        在我们程序中会使用到内存，我们一般叫做堆栈内存，所以内存是分成两种的，一种是堆内存， 一种是栈内存。GC只会回收堆内存，不会回收栈内存，这是为什么呢？ 

        主要原因是栈内存是一块专用的内存，专门为了函数的运行而设置的内存。存储着函数中的局部变量以及调用栈，除此之外，栈中的数据都有一个特点----简单。比如局部变量就不能被函数外访问，所以这块内存在被使用完就可以直接释放。正式因为这个特点，栈中的数据可以通过简单的编译器指令自动清理，不需要通过GC来回收
    


## GC解决了什么问题
        我们从上面知道了GC只会回收堆内存，那么为什么堆中的内存要自动回收呢，早期的语言是没有自动垃圾回收的， 所以只能手动的申请/释放内存。这种做法除了增加工作量外，同时也很容易出现问题。

        在并发请求的情况下，如果手动释放申请的内存，可能是会错误释放掉还在使用的使用的内存，也可能重复释放，或者忘记释放导致内存泄漏。对于系统或者业务来说这都是受损的。


## 内存堆和内存栈堆区别
        1. 主题不同
        内存堆：是一个特定的存储区或者寄存器，他的一端是固定的，另一端是浮动的  
        内存栈：是一种运算受限的线性表
        2. 特点不同
        内存堆：允许程序在运行时动态的申请某个大小的内存空间
        内存栈；仅在表尾进行插入和删除操作的线性表，这一端被称为栈顶，相对的另一端被称为栈低。

## 总结
了解GC，其实就是了解自动回收堆内存的算法。主流的垃圾回收算法有两种，一种是追踪式垃圾回收算法，另一种是引用计数法。

        1.追踪式GC
            追踪回收算法的核心都是采用简洁的回收策略，也就是策略并非寻找垃圾本身，而是先寻找那些对象存活，然后在反过来判断其余所有的对象为垃圾对象。从根对象出发，根据对象之间的引用信息，一步步推进直到扫描完整个堆并确定那些对象存活。目前go，java等语言的是实现都是追踪式GC
            
            ** 追踪式GC分类
                *** 标记-清除：从根对象出发，将确定存活的对象进行标记，并清除可以回收的对象。
                *** 标记-整理：为了解决内存碎片的问题而提出，在标记过程中，将对象尽可能整理到一块连续的内存上。
                *** 分代式：将对象根据存活时间的长短进行分类，存活时间小于某个值的为年轻代，存活时间大于某个值的为老年代，永远不会参与回收的对象为永久代。并根据分代假设（如果一个对象的存活时间不长则倾向于被回收，如果一个对象已经存活了很长时间则倾向于存活更长时间）对对象进行回收

        2.引用计数法
            每个对象自身都包含一个被引用的计数器，当计数器归0时自动得到回收。在追求高性能时不被应用。目前python，object-c等语言均是引用计数式GC



GO的GC目前使用的是无分代，不整理， 并发(和用户代码并发执行)的三色标记法，原因在于：

        1. 对象整理的优势在于解决内存碎片的问题以及允许使用顺序内存分配器，但是go运行时的分配算法基于tcmalloc，基本上没有碎片问题。并且顺序内存分配器再多线程的场景下并不适用。go使用的是基于tcmalloc的现代内存分配算法，对对象进行整理不会带来实质性的性能提升。
        2. 分代GC依赖于分代假设，即GC将主要的回收目标放在新创建的对象上(存活时间短，更倾向于被回收)，而非频繁检查所有对象。但GO的编译器会通过逃逸分析将大部分新生对象存储在栈上(栈直接回收)，只有那些长期存在对象才会被分配到需要进行垃圾回收的堆中。所以分代GC回收的那些存活时间短的对象在go中是直接分配到栈中的，当goroutine死亡后栈也会被直接回收，不需要GC的参与，进而分代假设没有带来任何优势。并且go的垃圾回收器和用户的代码并发执行，使得STW的时间与对象的代际，对象的size没有关系。
        