## 什么是堆和栈
我们在这里说堆和栈不是数据结构中的堆和栈，而是操作系统中的概念

* 栈 

    在程序中每个函数块都会有自己的内存区域，用来存自己的局部变量，返回地址，返回值等数据，这一块区域有特定的结构和寻址方式，大小在编译时已经确定，寻址起来也很迅速，开销很少。这一块的内存地址成为栈，栈是线程级别的，所以当数据太大的时候会发生栈溢出。
* 堆        
    在程序中全局变量，内存占用大的局部变量，发生了逃逸的局部变量存在的地方就是堆，这一块内存没有特定的结构，也没有固定的大小，可以根据需要进行调整。简单来说，有大量数据要存的时候，就是存在堆中。堆是进程级别的，当一个变量需要分配在堆上的时候，开销是比较大的，对于go这种带GC的语言来说，也会增加gc的压力，同时也容易造成内存碎片。

## 如何进行逃逸分析？
        在golang中，所有的内存都是由runtime管理的，程序员不需要知道内存 的分配和回收，但是编译器是需要知道的，这样才能确定栈堆大小，哪些变量是需要new堆上。逃逸分析决定了一个变量是分配在堆上还是在栈上。           
        golang逃逸分析最基本的原则是：如果一个函数返回的是一个(局部)变量的地址，那么这个变量就发生了逃逸


```golang
package main

func main() {
	a := f1()
	*a++
}

//go:noinline
func f1() *int {
	i := 1
	return &i
}
```

        在以上代码中，给 f1 增加了 noinline 标记，让 go 编译器不要将函数内联(简单来说就是把简短的函数在调用它的地方展开，以便可以看到方法内的内存分配过程)。        
        golang 提供了编译的参数让我们可以直观地看到变量是否发生了逃逸，只需要在 go build 时指定 -gcflags '-m' 即可：
```golang
$ go build -gcflags '-m' escape.go
# command-line-arguments
./escape.go:3:6: can inline main
./escape.go:11:9: &i escapes to heap
./escape.go:10:2: moved to heap: i
```
这样我们可以很直观的看到第10行， 11行变量发生了逃逸，内存会被直接分配到堆上