## 计算机七层网络模型       
物理层，数据链路层，网络层，传输层（会话层，表示层）和应用层。从协议上来讲：
* tcp是传输层协议
* http是应用层协议，主要解决如何包装数据（文本信息），是建立在tcp协议之上的应用。
* socket是针对tcp和udp的具体接口实现，提供了在传输层进行网络编程的方法

## 为何有了http还要有rpc调用？ 
rpc和http不是对立面，rpc可以使用http作为通信协议。rpc是一种设计，实现框架，通信协议只是其中一部分。rpc本质是一只轻量无感知的跨进程间通信方式

## 实现     
rpc的实现： grpc，Thrift，Dubbo

## RPC 核心之功能实现
* 服务寻址：服务器上的应用需要告知rpc框架：B服务器地址，端口，调用函数名。所以必须实现待调用方法到 call ID 的映射。
* 数据流的序列化和反序列化：由于网络协议都是二进制的，所以调用方法的参数在进行传递时首先需要序列化成二进制。
* 网络传输：在客户端和服务端简历数据传输通道，大都是采用TCP连接（grpc采用了http2）


## 流程
* 服务消费者（Client 客户端）通过本地调用的方式调用服务。
* 客户端存根（Client Stub）接收到调用请求后负责将方法、入参等信息序列化（组装）成能够进行网络传输的消息体。
* 客户端存根（Client Stub）找到远程的服务地址，并且将消息通过网络发送给服务端。
* 服务端存根（Server Stub）收到消息后进行解码（反序列化操作）。
* 服务端存根（Server Stub）根据解码结果调用本地的服务进行相关处理
* 服务端(Server)本地服务业务处理。
* 处理结果返回给服务端存根（Server Stub）。
* 服务端存根（Server Stub）序列化结果。
* 服务端存根（Server Stub）将结果通过网络发送至消费方。
* 客户端存根（Client Stub）接收到消息，并进行解码（反序列化）。
* 服务消费方得到最终结果。

## grpc     
grpc是谷歌开源的一个rpc框架，面向移动和http2设计 
* 内容交换格式采用protobuf
* 传输协议使用http2
## HTTP/2 介绍
* 采用新的二进制格式    
http1.x都是基于文本解析，而因为文本表现形式的多样性，基于文本协议的格式解析天然存在健壮性，而采用二进制格式后实现方便且健壮，
* 多路复用  
    多个request公用一个连接
* header 压缩           
在http1.x中header信息比较多且每次都会重复发送，造成浪费。HTTP2.0 使用 encoder 减少了传输的 header 大小，且通信双方都包含了一份header信息表，此后的请求可以只发送差异数据，避免信息的重复传输，进一步减小需要传输的内容大小。
* 服务端推送        
主要思想是：当一个客户端请求资源x，而服务器指导它很可能也需要资源z的情况下，服务器可以在客户端发送请求前，主动将资源z推给客户端。