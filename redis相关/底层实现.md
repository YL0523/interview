<!-- TOC -->

- [DICT](#dict)
    - [dict具体实现](#dict具体实现)
    - [详解](#详解)
    - [dict的创建](#dict的创建)
    - [dict的查找](#dict的查找)
    - [增量式重哈希_dictRehashStep的实现](#增量式重哈希_dictrehashstep的实现)
    - [dict的插入（dictAdd）](#dict的插入dictadd)
    - [dictReplace在dictAdd基础上实现](#dictreplace在dictadd基础上实现)
    - [dict的删除（dictDelete）](#dict的删除dictdelete)
- [SDS](#sds)

<!-- /TOC -->
# DICT
## dict具体实现
代码实现
```golang
typedef struct dictEntry {
    void *key;
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;
    struct dictEntry *next;
} dictEntry;

typedef struct dictType {
    unsigned int (*hashFunction)(const void *key);
    void *(*keyDup)(void *privdata, const void *key);
    void *(*valDup)(void *privdata, const void *obj);
    int (*keyCompare)(void *privdata, const void *key1, const void *key2);
    void (*keyDestructor)(void *privdata, void *key);
    void (*valDestructor)(void *privdata, void *obj);
} dictType;

/* This is our hash table structure. Every dictionary has two of this as we
 * implement incremental rehashing, for the old to the new table. */
typedef struct dictht {
    dictEntry **table;
    unsigned long size;
    unsigned long sizemask;
    unsigned long used;
} dictht;

typedef struct dict {
    dictType *type;
    void *privdata;
    dictht ht[2];
    long rehashidx; /* rehashing not in progress if rehashidx == -1 */
    int iterators; /* number of iterators currently running */
} dict;
```

图表示意
![avatar](redis-dict底层实现.png)

结合上面的代码和结构图示意，可以很清楚地看出dict的结构和组成：
* 一个指向dictType结构的指针（type）。他通过自定义的方式使得dict的key和value能够存储任何类型的数据。
* 一个私有域的指针（prividata）。由调用者在创建dict的时候传进来
* 两个哈希表（ht[2]）。只有在重哈希的过程中ht[0]和ht[1]才都有效，平时只有ht[0]有效。
* 当前重哈希索引(rehashidx)。如果rehsashindex = -1 ,表示当前没有在重哈希过程中；否则，表示当前正在重哈希，并且他的值记录了当前重哈希进行到了哪一步
* 当前正在进行遍历的iterators的个数


## 详解
* dictType：包含若干函数指针，用于dict的调用者对设计key和value的各种操作的自定义
    * hashFunction，对key进行哈希计算的哈希算法
    * keyDup和valueDup，分别定义key和value的拷贝函数，用于在需要的时候对key和value进行深拷贝，而不仅仅是传递传递对象指针
    * keyCompare，定义两个key的比较操作，在根据key进行查找时会用到。
    * keyDestructor和valDestructor，分别定义对key和value的析构函数。
* 私有数据指针（privdata）就是在dictType的某些操作被调用时会传回给调用者。
* dictht结构：  
    * 一个dictEntry指针数组(table)，key的哈希值最终映射到在这个数组的某个位置上（对应一个bucket）。如果多个key映射到了同一个位置上，就发生了冲突，那么就拉出一个dictEntry链表
    * size：标示dicyEntry指针数组的长度，他总是2的指数
    * sizemask：用于将哈希值映射到table的位置索引。他的值等于（size - 1），比如7，15，31，63，等等。也就是用二进制表示的各个bit全是1的数字。每个key先经过hashFunction计算得到一个哈希值， 然后计算(哈希值&sizemask)得到table上的位置。相当于计算取余（哈希值%size）
    * used：记录dict中现有的数据个数，它与size的比值就是装载因子。这个比值越大，哈希冲突发生的概率就越大。  

dictEntry结构中包含k,v和指向下一个的next指针。k是void指针，这意味着它可以指向任何类型。v是个union(集合)，当它的值是uint64_t，int64_t或者double类型时，就不需要额外的存储，这有利于减少内存碎片。当然v也可以是void指针，以便与存储任何类型的数据


## dict的创建
```C
    dict *dictCreate(dictType *type,
            void *privDataPtr)
    {
        dict *d = zmalloc(sizeof(*d));

        _dictInit(d,type,privDataPtr);
        return d;
    }

    int _dictInit(dict *d, dictType *type,
            void *privDataPtr)
    {
        _dictReset(&d->ht[0]);
        _dictReset(&d->ht[1]);
        d->type = type;
        d->privdata = privDataPtr;
        d->rehashidx = -1;
        d->iterators = 0;
        return DICT_OK;
    }

    static void _dictReset(dictht *ht)
    {
        ht->table = NULL;
        ht->size = 0;
        ht->sizemask = 0;
        ht->used = 0;
    }
```
* dictCreate为dict的数据结构分配空间并为各个变量初始化，其中两个哈希表ht[0]和ht[1]没有分配空间，table指针都赋值为null，这意味着要等第一个指针插入时才会真正分配空间


## dict的查找
```C
    dictEntry *dictFind(dict *d, const void *key)
    {
        dictEntry *he;
        unsigned int h, idx, table;

        if (d->ht[0].used + d->ht[1].used == 0) return NULL; /* dict is empty */
        if (dictIsRehashing(d)) _dictRehashStep(d);
        h = dictHashKey(d, key);
        for (table = 0; table <= 1; table++) {
            idx = h & d->ht[table].sizemask;
            he = d->ht[table].table[idx];
            while(he) {
                if (key==he->key || dictCompareKeys(d, key, he->key))
                    return he;
                he = he->next;
            }
            if (!dictIsRehashing(d)) return NULL;
        }
        return NULL;
    }
```
* 如果当前正在进行重哈希，那么将重哈希过程向前推进一波(即调用_dictRehashStep)。实际上，除了查找，插入和删除也都会触发这一动作
* 计算key的哈希值，(调用dictHashKey,里面的实现会调用前面提到的hashFunction)
* 现在第一个哈希表ht[0]上进行查找。在table数组上滴味道哈希值对应的位置(如前所述，通过哈希值与sizemask进行按位与)，然后在对应的dictEndtry链表上进行查找，查找的时候和key进行对比，这个时候调用dictCompareKeys，它里面的实现会调用到前面提到的keyCompare。如果找到就返回该项，否则就下一步
* 判断当前是否在重哈希，如果没有，那么在ht[0]上的查找结果就是最终结果（没找到，返回null）。否则，在ht[1]上查找

## 增量式重哈希_dictRehashStep的实现
```C
static void _dictRehashStep(dict *d) {
    if (d->iterators == 0) dictRehash(d,1);
}

int dictRehash(dict *d, int n) {
    int empty_visits = n*10; /* Max number of empty buckets to visit. 最大访问空桶数*/
    if (!dictIsRehashing(d)) return 0;

    while(n-- && d->ht[0].used != 0) {
        dictEntry *de, *nextde;

        /* Note that rehashidx can't overflow as we are sure there are more
         * elements because ht[0].used != 0 */
        assert(d->ht[0].size > (unsigned long)d->rehashidx);
        while(d->ht[0].table[d->rehashidx] == NULL) {
            d->rehashidx++;
            if (--empty_visits == 0) return 1;
        }
        de = d->ht[0].table[d->rehashidx];
        /* Move all the keys in this bucket from the old to the new hash HT */
        while(de) {
            unsigned int h;

            nextde = de->next;
            /* Get the index in the new hash table */
            h = dictHashKey(d, de->key) & d->ht[1].sizemask;
            de->next = d->ht[1].table[h];
            d->ht[1].table[h] = de;
            d->ht[0].used--;
            d->ht[1].used++;
            de = nextde;
        }
        d->ht[0].table[d->rehashidx] = NULL;
        d->rehashidx++;
    }

    /* Check if we already rehashed the whole table... */
    if (d->ht[0].used == 0) {
        zfree(d->ht[0].table);
        d->ht[0] = d->ht[1];
        _dictReset(&d->ht[1]);
        d->rehashidx = -1;
        return 0;
    }

    /* More to rehash... */
    return 1;
}
```
* dictRehash每次将重哈希至少向前推进n步（除非不到n步整个哈希就结束了），每一步都将ht[0]上某一个bucket(即一个dictEntry链表)上的每一个dictEntry移动到ht[1]上，他在ht[1]上的位置根据ht[1]上的sizemask进行重新计算。rehashidx记录了当前尚未迁移(有待迁移)的ht[0]的bucket位置。
* 如果dictRehash被调用的时候，rehashidx指向的bucket里一个dictEntry也没有，那么他就没有可迁移的数据，这时它尝试在ht[0].table中不断向后遍历，直到找到下一个存有数据的bucket位置。如果一直找不到，最多走n*10步，本次重哈希暂告结束

* 最后如果ht[0]上的数据都迁移到了ht[1]上了（即d->ht[0].used == 0），那么整个重哈希结束，ht[0]变成ht[1]的内容，而ht[1]重置为空。根据以上对重哈希过程的分析，我们容易看出，本文前面的dict结构图中所展示的正是rehashidx=2时的情况，前面两个bucket（ht[0].table[0]和ht[0].table[1]）都已经迁移到ht[1]上去了。
## dict的插入（dictAdd）
* dictAdd插入新的一对key和value，如果key已经存在，则插入失败
* dictrePlace也是插入一对key和value，不过在key存在的时候，他会更新value
```C
    int dictAdd(dict *d, void *key, void *val)
    {
        dictEntry *entry = dictAddRaw(d,key);

        if (!entry) return DICT_ERR;
        dictSetVal(d, entry, val);
        return DICT_OK;
    }

    dictEntry *dictAddRaw(dict *d, void *key)
    {
        int index;
        dictEntry *entry;
        dictht *ht;

        if (dictIsRehashing(d)) _dictRehashStep(d);

        /* Get the index of the new element, or -1 if
        * the element already exists. */
        if ((index = _dictKeyIndex(d, key)) == -1)
            return NULL;

        /* Allocate the memory and store the new entry.
        * Insert the element in top, with the assumption that in a database
        * system it is more likely that recently added entries are accessed
        * more frequently. */
        ht = dictIsRehashing(d) ? &d->ht[1] : &d->ht[0];
        entry = zmalloc(sizeof(*entry));
        entry->next = ht->table[index];
        ht->table[index] = entry;
        ht->used++;

        /* Set the hash entry fields. */
        dictSetKey(d, entry, key);
        return entry;
    }

    static int _dictKeyIndex(dict *d, const void *key)
    {
        unsigned int h, idx, table;
        dictEntry *he;

        /* Expand the hash table if needed */
        if (_dictExpandIfNeeded(d) == DICT_ERR)
            return -1;
        /* Compute the key hash value */
        h = dictHashKey(d, key);
        for (table = 0; table <= 1; table++) {
            idx = h & d->ht[table].sizemask;
            /* Search if this slot does not already contain the given key */
            he = d->ht[table].table[idx];
            while(he) {
                if (key==he->key || dictCompareKeys(d, key, he->key))
                    return -1;
                he = he->next;
            }
            if (!dictIsRehashing(d)) break;
        }
        return idx;
    }
```
以上是dictAdd的关键代实现代码。我们需要注意以下几点：   
* 它也会触发推进一步重哈希
* 如果正在重哈希中，它会把数据插入到ht[1]；否则插入到ht[0]
* 在对应的bucket中插入数据的时候，总是插入到dictEntry
的头部。因为新数据接下来被访问的概率比较高，这样再次查找它时比较的次数比较少。
* _dictKeyIndex在dict中寻找插入位置，如果不在重哈希过程中，他只查找ht[0]，否则两个都查找
* _dictKeyIndex可能触发dict内存扩展(_dictExpandIfNeeded，他将哈希表长度扩展为原来的两倍)

## dictReplace在dictAdd基础上实现
```C
    int dictReplace(dict *d, void *key, void *val)
    {
        dictEntry *entry, auxentry;

        /* Try to add the element. If the key
        * does not exists dictAdd will suceed. */
        if (dictAdd(d, key, val) == DICT_OK)
            return 1;
        /* It already exists, get the entry */
        entry = dictFind(d, key);
        /* Set the new value and free the old one. Note that it is important
        * to do that in this order, as the value may just be exactly the same
        * as the previous one. In this context, think to reference counting,
        * you want to increment (set), and then decrement (free), and not the
        * reverse. */
        auxentry = *entry;
        dictSetVal(d, entry, val);
        dictFreeVal(d, &auxentry);
        return 0;
    }
```
在key已经存在的情况下，dictReplace会同时调用dictAdd和dictFind

## dict的删除（dictDelete）
* dictDelete也会触发推进一步重哈希(_dictRehashStep)
* 如果当前不在重哈希过程中，它只在ht[0]中查找要删除的key，否则两个都找
* 删除成功后会调用key和value的析构函数

# SDS
## 构成
除了sdshdr5之外，其他4个header的结构都包含3个字段       
* len： 表示字符传的真正长度（不包含NULL结束符在内）
* alloc：表示字符串的最大容量（不包含最后多余的那个字节）
* flags：总是占用一个字节，其中的最低3个bit用来表示header的类型。header的类型共有5中，常量定义如下：
    ```C
    define SDS_TYPE_5  0
    define SDS_TYPE_8  1
    define SDS_TYPE_16 2
    define SDS_TYPE_32 3
    define SDS_TYPE_64 4
    ```

![avater](SDS.png)

        上图是sds的一个内部结构的例子，图中展示了两个sds字符串s1和s2的内存结构，一个使用sdshdr8类型的header，另一个使用sdsher16类型的header。但是他们都表达了同样的一个长度为6的字符串的值："titlei"。


sds的字符指针(s1和s2)就是指向真正的数据(字符数组)开始的位置，而header位于内存地址较低的方向，

```C
define SDS_TYPE_MASK 7
define SDS_TYPE_BITS 3
define SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));
define SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))
define SDS_TYPE_5_LEN(f) ((f)>>SDS_TYPE_BITS)
```
其中SDS_HDR用来从sds字符串获取header起始位置的指针，比如SDS_HDR(8,s1)表示s1的header指针，SDS_HDR(16, s2)表示s2的header指针。        

在使用SDS_HDR之前我们通过由sds字符指针获得header类型的方法是，先向低地址方向偏移1个字节的位置，得到flags字段，比如，s1[-1]和s2[-1]分别获得了s1和s2的flags值。然后取flahs的最低3个bit得到header的类型    

* 由于s1[-1] == 0x01 == SDS_TYPE_8，因此s1的header类型是sdshdr8。
* 由于s2[-1] == 0x02 == SDS_TYPE_16，因此s2的header类型是sdshdr16。
有了header指针，就能很快定位到他的len和alloc字段：  
* s1的header中，len的值为0x06 ，表示字符串数据长度为6，alloc的值为0x80,表示字符数组最大容量为128
* s2的header中，len的值为0x0006，表示数据长度为6，alloc的值为0x03E8,表示字符数组最大容量为1000