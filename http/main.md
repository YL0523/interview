## http/1.1的缺陷       
1. 高延迟-带来页面加载速度的降低    
    网络延迟问题主要是由于队头阻塞问题，导致带宽无法充分利用。
    * 队头阻塞是指当顺序发送的请求中的一个请求因为某种原因被阻塞了，在后面排队的所有请求也一并被阻塞，并导致客户端迟迟收不到数据
2. 无状态特性-带来巨大的http头部            
由于报文header一般会携带"User Agent,Cookie,Accept,Server"等固定字段，增加了传输成本
3. 明文传输-带来的不安全性      
http1.1在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，无法保证数据的安全。例： 免费wifi陷阱
4. 不支持服务端推送消息

正式由于以上的http协议的缺陷，2009年谷歌公布了自行研发的SPDY技术。 SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。
## http2 相比http1.1有什么优势
同域名下所有的通信都在单个连接上完成，该连接可以承载任意数量的双向数据流，每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装
1. 二进制分帧   
    * http/2数据通信的最小单位消息；http/2中逻辑上的http消息。例如请求和响应等消息由一个或多个帧组成
    * 流：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有唯一的整数ID    
    HTTP/2 将请求和响应数据分割为更小的帧，采用二进制格式编码传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效。

 
2. 服务器推送               
    服务端可以在发送页面html时主动推送其他资源，而不用等到浏览器的解析到响应的位置，发起请求在响应。例如服务端可以主动把js和css文件推送给客户端，而不需要客户端解析HTML时发送这些请求，服务端可以主动推送，客户端也有权利选择是否接收。

3. 头部压缩             
http/1.x会在请求t和响应中重复地携带不常改变，冗长的头部数据，给网络带来额外的负担，开发了专门的hpack算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还采用哈夫曼编码来压缩整数和字符串
    * HTTP/2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送
    * 首部表在http2的连接期间始终存在，由客户端和服务端共同渐进的推进更新
    * 每个新的首部键-值对要么被追加到当前表尾，要么替换表中之前的值（你可以理解为只发送差异数据，而不是全部发送，从而减少头部的信息量）

4. 多路复用     
    * 在http1.x中，如果想并发多个请求，必须使用多个TCP连接，且浏览器为了控制资源，还会对单个域名有6-8个TCP连接的限制
    * http2中：
        * 同域名下所有通信都是在单个连接上完成
        * 单个连接可以承载任意数量的双向数据流
        * 数据流以消息的形式发送，而消息又由一个或多个帧的情况组成，多个帧之间乱序发送，因为根据帧首部的流标识可以重新组装
    * 同个域名只需要占用一个 TCP 连接，使用一个连接并行发送多个请求和响应,消除了因多个 TCP 连接而带来的延时和内存消耗。
    * 并行交错地发送多个请求，请求之间互不影响。
    * 并行交错地发送多个响应，响应之间互不干扰。
    * 在HTTP/2中，每个请求都可以带一个31bit的优先值，0表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。

## HTTPS握手过程的简单描述如下：
1. 客户端发起一个http请求，告诉服务器自己支持哪些hash算法
2. 服务端把自己的信息以数字证书的形式返回给客户端（证书内容有公钥，网站地址，证书颁发机构，失效日期等）。证书中有一个公钥来加密信息，私钥由服务端来持有
3. 验证证书的合法性，客户端在收到服务端的响应后会先验证证书的合法性，
4. 生成随机密码（RSA签名），如果验证通过，浏览器就会生成一个随机的对称密钥并使用公钥加密，让服务端用私钥解密，解密后就用这个对称密钥进行传输了，并且能够说明服务端确实是私钥的持有者。
5. 生成对称加密算法，验证完服务端身份之后，客户端生成一个对称加密的算法和对应的密钥，以公钥加密之后发送给服务端。之后客户端与服务端可以用这个对称加密算法来加密和解密通信内容了。

### 在通信过程中，黑客可以截获加密内容，虽不能理解具体内容，但可以捣乱，修改内容或重复发送该内容，如何解决？
    给通信的内容加上版本号或者是随机值，如果接收到版本号或随机值不相同的信息，双方立刻停止通信。
### 客户端生成随机数并用公钥加密，让服务端用私钥解密来确保对方是否真的持有私钥。但是，黑客也可以发送字符串让服务器用私钥加密，并得到加密后的信息，从而找到规律，导致私钥的安全性下降。如何解决？
    服务端并不是真的加密这个字符串，而是把字符串进行hash计算后再进行加密后发送给客户端。客户端收到后再解密这个hash值与原来字符串的hash值对比，从而确定对方是否持有私钥。



## session和cookie有什么区别  
1. 存放位置不同         
    cookie存放在客户端，临时文件中；session存放在服务器内存中，一个session域对象为一个用户浏览器服务
2. 安全性   
    cookie是以文明的方式存放在客户端，安全性低，可以通过一个加密算法进行加密后存放；session存放于服务器内存中，所以安全性好
3. 生命周期
4. 访问范围



